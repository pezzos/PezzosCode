#!/usr/bin/env bash
# Purpose: Copy repo docs, skills, and tooling into another repo for bootstrapping.
set -euo pipefail

if [[ $# -ne 1 ]]; then
  echo "Usage: $(basename "$0") <target-repo-path>" >&2
  exit 1
fi

repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
target_repo="$1"

if [[ ! -d "$target_repo" ]]; then
  echo "Target repo does not exist: $target_repo" >&2
  exit 1
fi

marker_for_file() {
  local file="$1"
  local base
  base="$(basename "$file")"

  if [[ "$base" == "Makefile" ]]; then
    echo "# PezzosCode bootstrap"
    return
  fi

  case "${file##*.}" in
    md)
      echo "<!-- PezzosCode bootstrap -->"
      ;;
    sh|bash|zsh|yml|yaml|toml|txt)
      echo "# PezzosCode bootstrap"
      ;;
    *)
      echo "# PezzosCode bootstrap"
      ;;
  esac
}

has_marker() {
  local file="$1"
  local marker
  marker="$(marker_for_file "$file")"

  [[ -f "$file" ]] || return 1
  [[ "$(tail -n 1 "$file" 2>/dev/null || true)" == "$marker" ]]
}

append_marker() {
  local file="$1"
  local marker
  marker="$(marker_for_file "$file")"

  if [[ -f "$file" ]]; then
    if [[ "$(tail -n 1 "$file" 2>/dev/null || true)" == "$marker" ]]; then
      return
    fi
    printf "\n%s\n" "$marker" >> "$file"
  fi
}

prompt_action() {
  local dest="$1"
  local choice
  local prompt_in="/dev/tty"

  if [[ ! -r "$prompt_in" ]]; then
    prompt_in="/dev/stdin"
  fi

  while true; do
    echo "File exists: $dest" >&2
    echo "Choose action: [o]verwrite, [m]erge (codex), [s]kip" >&2
    read -r -p "Selection: " choice < "$prompt_in"
    case "$choice" in
      o|O)
        echo "overwrite"
        return
        ;;
      m|M)
        echo "merge"
        return
        ;;
      s|S|"")
        echo "skip"
        return
        ;;
      *)
        echo "Invalid choice."
        ;;
    esac
  done
}

codex_merge_file() {
  local src="$1"
  local dest="$2"
  local tmp_output
  local tmp_merged
  local prompt

  if ! command -v codex >/dev/null 2>&1; then
    echo "Codex CLI not found. Skipping merge for $dest." >&2
    return 1
  fi

  tmp_output="$(mktemp)"
  tmp_merged="$(mktemp)"
  prompt=$(
    cat <<EOF
Merge the source file into the destination file. Preserve destination edits unless the source has clearer, newer structure.
Source file: $src
Destination file: $dest
Output ONLY the merged file content, no explanations, no code fences.
EOF
  )

  if ! codex exec --skip-git-repo-check --output-last-message "$tmp_output" --full-auto --dangerously-bypass-approvals-and-sandbox "$prompt"; then
    echo "Codex merge failed; skipping $dest." >&2
    rm -f "$tmp_output" "$tmp_merged"
    return 1
  fi

  if command -v rg >/dev/null 2>&1; then
    if rg -q '^```' "$tmp_output"; then
      awk 'BEGIN{in=0} /^```/{if(in==0){in=1;next}else{exit}} {if(in) print}' "$tmp_output" > "$tmp_merged"
    else
      cp "$tmp_output" "$tmp_merged"
    fi
  else
    if grep -q '^```' "$tmp_output"; then
      awk 'BEGIN{in=0} /^```/{if(in==0){in=1;next}else{exit}} {if(in) print}' "$tmp_output" > "$tmp_merged"
    else
      cp "$tmp_output" "$tmp_merged"
    fi
  fi

  if [[ ! -s "$tmp_merged" ]]; then
    echo "Codex merge produced empty output; skipping $dest." >&2
    rm -f "$tmp_output" "$tmp_merged"
    return 1
  fi

  mkdir -p "$(dirname "$dest")"
  cp "$tmp_merged" "$dest"
  rm -f "$tmp_output" "$tmp_merged"
  return 0
}

copy_file() {
  local src="$1"
  local dest="$2"
  local action

  if [[ -f "$dest" ]]; then
    if has_marker "$dest"; then
      echo "Skipping (already bootstrapped): $dest"
      return 0
    fi

    if cmp -s "$src" "$dest"; then
      echo "Skipping (no changes): $dest"
      return 0
    fi

    action="$(prompt_action "$dest")"
    case "$action" in
      overwrite)
        mkdir -p "$(dirname "$dest")"
        cp "$src" "$dest"
        append_marker "$dest"
        ;;
      merge)
        if codex_merge_file "$src" "$dest"; then
          append_marker "$dest"
        else
          echo "Skipped (merge failed): $dest"
        fi
        ;;
      skip)
        echo "Skipped: $dest"
        ;;
    esac
  else
    mkdir -p "$(dirname "$dest")"
    cp "$src" "$dest"
    append_marker "$dest"
  fi
}

copy_dir_files() {
  local src_dir="$1"
  local dest_dir="$2"
  local src_file
  local rel

  [[ -d "$src_dir" ]] || return 0

  while IFS= read -r -d '' src_file; do
    rel="${src_file#$src_dir/}"
    copy_file "$src_file" "$dest_dir/$rel"
  done < <(find "$src_dir" -type f -print0)
}

copy_dir_files "$repo_root/docs" "$target_repo/docs"
copy_dir_files "$repo_root/.codex/skills" "$target_repo/.codex/skills"
copy_dir_files "$repo_root/tools" "$target_repo/tools"
copy_file "$repo_root/AGENTS.md" "$target_repo/AGENTS.md"
copy_file "$repo_root/Makefile" "$target_repo/Makefile"
