#!/usr/bin/env bash
# Purpose: Copy repo docs, skills, and tooling into another repo for bootstrapping.
set -euo pipefail

usage() {
  cat <<'EOF' >&2
Usage: bootstrap-into [--reapply] <target-repo-path>

Options:
  --reapply   For files that differ, prompt even if a bootstrap marker exists.
EOF
}

reapply=false
while [[ $# -gt 0 ]]; do
  case "$1" in
    --reapply)
      reapply=true
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      exit 1
      ;;
    *)
      break
      ;;
  esac
done

if [[ $# -ne 1 ]]; then
  usage
  exit 1
fi

repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
target_repo="$1"

if [[ ! -d "$target_repo" ]]; then
  echo "Target repo does not exist: $target_repo" >&2
  exit 1
fi

marker_for_file() {
  local file="$1"
  local base
  base="$(basename "$file")"

  if [[ "$base" == "Makefile" ]]; then
    echo "# PezzosCode bootstrap"
    return
  fi

  case "${file##*.}" in
    md)
      echo "<!-- PezzosCode bootstrap -->"
      ;;
    sh|bash|zsh|yml|yaml|toml|txt)
      echo "# PezzosCode bootstrap"
      ;;
    *)
      echo "# PezzosCode bootstrap"
      ;;
  esac
}

has_marker() {
  local file="$1"
  local marker
  marker="$(marker_for_file "$file")"

  [[ -f "$file" ]] || return 1
  [[ "$(tail -n 1 "$file" 2>/dev/null || true)" == "$marker" ]]
}

append_marker() {
  local file="$1"
  local marker
  marker="$(marker_for_file "$file")"

  if [[ -f "$file" ]]; then
    if [[ "$(tail -n 1 "$file" 2>/dev/null || true)" == "$marker" ]]; then
      return
    fi
    printf "\n%s\n" "$marker" >> "$file"
  fi
}

normalize_for_compare() {
  local file="$1"
  local out="$2"
  local marker

  marker="$(marker_for_file "$file")"

  awk -v marker="$marker" '
  { lines[NR] = $0 }
  END {
    n = NR
    while (n > 0 && lines[n] ~ /^[[:space:]]*$/) { n-- }
    if (n > 0 && lines[n] == marker) { n-- }
    while (n > 0 && lines[n] ~ /^[[:space:]]*$/) { n-- }
    for (i = 1; i <= n; i++) { print lines[i] }
  }' "$file" > "$out"
}

files_equal_ignoring_marker() {
  local src="$1"
  local dest="$2"
  local tmp_src
  local tmp_dest

  tmp_src="$(mktemp)"
  tmp_dest="$(mktemp)"

  normalize_for_compare "$src" "$tmp_src"
  normalize_for_compare "$dest" "$tmp_dest"

  if cmp -s "$tmp_src" "$tmp_dest"; then
    rm -f "$tmp_src" "$tmp_dest"
    return 0
  fi

  rm -f "$tmp_src" "$tmp_dest"
  return 1
}

prompt_action() {
  local dest="$1"
  local choice
  local prompt_in="/dev/tty"

  if [[ ! -r "$prompt_in" ]]; then
    prompt_in="/dev/stdin"
  fi

  while true; do
    echo "File exists: $dest" >&2
    echo "Choose action: [o]verwrite, [m]erge (codex), [s]kip" >&2
    read -r -p "Selection: " choice < "$prompt_in"
    case "$choice" in
      o|O)
        echo "overwrite"
        return
        ;;
      m|M)
        echo "merge"
        return
        ;;
      s|S|"")
        echo "skip"
        return
        ;;
      *)
        echo "Invalid choice."
        ;;
    esac
  done
}

codex_merge_file() {
  local src="$1"
  local dest="$2"
  local tmp_output
  local tmp_merged
  local prompt
  local git_log
  local git_blame
  local git_context=""

  if ! command -v codex >/dev/null 2>&1; then
    echo "Codex CLI not found. Skipping merge for $dest." >&2
    return 1
  fi

  tmp_output="$(mktemp)"
  tmp_merged="$(mktemp)"

  if git -C "$repo_root" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    git_log="$(git -C "$repo_root" log -n 5 --pretty=format:'%h %ad %s' --date=short -- "$src" 2>/dev/null || true)"
    git_blame="$(git -C "$repo_root" blame -n -- "$src" 2>/dev/null | head -n 120 || true)"
    if [[ -n "$git_log" || -n "$git_blame" ]]; then
      git_context=$(
        cat <<EOF

Template file history (for context only):
Git log (last 5):
${git_log:-[no log available]}

Git blame (first 120 lines):
${git_blame:-[no blame available]}
EOF
      )
    fi
  fi

  prompt=$(
    cat <<EOF
Merge the source file into the destination file. Preserve destination edits unless the source has clearer, newer structure.
Source file: $src
Destination file: $dest
The destination file is an active project document, not a template. Keep its content and only add missing or improved sections from the source template that do not exist yet.
Output ONLY the merged file content, no explanations, no code fences.
$git_context
EOF
  )

  if ! codex exec --skip-git-repo-check --output-last-message "$tmp_output" --dangerously-bypass-approvals-and-sandbox "$prompt" >/dev/null 2>/dev/null; then
    echo "Codex merge failed; skipping $dest." >&2
    rm -f "$tmp_output" "$tmp_merged"
    return 1
  fi

  if command -v rg >/dev/null 2>&1; then
    if rg -q '^```' "$tmp_output"; then
      awk 'BEGIN{in=0} /^```/{if(in==0){in=1;next}else{exit}} {if(in) print}' "$tmp_output" > "$tmp_merged"
    else
      cp "$tmp_output" "$tmp_merged"
    fi
  else
    if grep -q '^```' "$tmp_output"; then
      awk 'BEGIN{in=0} /^```/{if(in==0){in=1;next}else{exit}} {if(in) print}' "$tmp_output" > "$tmp_merged"
    else
      cp "$tmp_output" "$tmp_merged"
    fi
  fi

  if [[ ! -s "$tmp_merged" ]]; then
    echo "Codex merge produced empty output; skipping $dest." >&2
    rm -f "$tmp_output" "$tmp_merged"
    return 1
  fi

  mkdir -p "$(dirname "$dest")"
  cp "$tmp_merged" "$dest"
  rm -f "$tmp_output" "$tmp_merged"
  return 0
}

copy_file() {
  local src="$1"
  local dest="$2"
  local action

  if [[ -f "$dest" ]]; then
    if ! "$reapply" && has_marker "$dest"; then
      echo "Skipping (already bootstrapped): $dest"
      return 0
    fi

    if files_equal_ignoring_marker "$src" "$dest"; then
      echo "Skipping (no changes): $dest"
      return 0
    fi

    if "$reapply" && has_marker "$dest"; then
      echo "Reapply enabled; existing marker ignored for: $dest"
    fi

    action="$(prompt_action "$dest")"
    case "$action" in
      overwrite)
        mkdir -p "$(dirname "$dest")"
        cp "$src" "$dest"
        append_marker "$dest"
        ;;
      merge)
        if codex_merge_file "$src" "$dest"; then
          append_marker "$dest"
        else
          echo "Skipped (merge failed): $dest"
        fi
        ;;
      skip)
        echo "Skipped: $dest"
        ;;
    esac
  else
    mkdir -p "$(dirname "$dest")"
    cp "$src" "$dest"
    append_marker "$dest"
  fi
}

copy_dir_files() {
  local src_dir="$1"
  local dest_dir="$2"
  local src_file
  local rel

  [[ -d "$src_dir" ]] || return 0

  while IFS= read -r -d '' src_file; do
    rel="${src_file#$src_dir/}"
    copy_file "$src_file" "$dest_dir/$rel"
  done < <(find "$src_dir" -type f -print0)
}

copy_dir_files "$repo_root/docs" "$target_repo/docs"
copy_dir_files "$repo_root/.codex/skills" "$target_repo/.codex/skills"
copy_dir_files "$repo_root/tools" "$target_repo/tools"
copy_file "$repo_root/AGENTS.md" "$target_repo/AGENTS.md"
copy_file "$repo_root/.gitignore" "$target_repo/.gitignore"
copy_file "$repo_root/.gitmessage" "$target_repo/.gitmessage"
copy_file "$repo_root/LICENSE" "$target_repo/LICENSE"
copy_file "$repo_root/Makefile" "$target_repo/Makefile"
copy_file "$repo_root/pp.yml" "$target_repo/pp.yml"
